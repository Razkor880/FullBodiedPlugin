YOURASSIGNMENT – FBHide (Initial Invisibility + Reset)

This assignment is scoped to implementing the initial FBHide module only. Read these instructions, and refer to the checklist below as you work through the assignment. 

The goal is to deliver a minimal, reliable invisibility toggle and reset that can be safely expanded later.

TASK GOAL

Implement a broad invisibility toggle using the module name FBHide, with full reset support.

FBHide must:

Hide visible geometry only (mesh/shapes), not skeleton nodes

Be actor-scoped and reversible

Work for both caster and target

Reset cleanly on PairEnd / PairedStop / CancelAndReset

Integrate into the existing INI -> Timeline -> ActorManager pipeline

This is a v1 feature. No body-part specificity is required yet.

NAMING CONSTRAINT (IMPORTANT)

FBHide is the canonical, user-facing name.

INI commands must use FBHide

Logs should refer to FBHide

Code identifiers may vary internally, but external naming must remain FBHide

Do not introduce alternate names such as FBVis, FBVisibility, or HideMesh at the user-facing level.

HARD CONSTRAINTS

Do NOT hide skeleton nodes or parent NiNodes

Do NOT rely on visibility inheritance

Do NOT introduce new threads, pumps, schedulers, or hooks

Do NOT break existing morph or scale behavior

Do NOT change INI grammar outside of adding FBHide(bool)

All operations must be safe on the game thread

RESET REQUIREMENT (CRITICAL)

Any visibility changes applied by FBHide must be fully undone by reset.

Reset must:

Restore original visibility state per shape

Apply to both caster and target

Run from existing reset paths (PairEnd / PairedStop / CancelAndReset)

No persistent invisibility is acceptable after reset.

IMPLEMENTATION EXPECTATIONS

Operate on renderable geometry (BSTriShape or equivalent)

Track baseline visibility state per actor

Restore exactly to baseline, not a hard-coded “visible” state

Safe no-op behavior if actor 3D is missing or unloaded

DELIVERABLE

FBHide(true/false) works in INI timelines.

Manual validation:

Actor becomes invisible when FBHide(true) executes

Actor becomes visible again on FBHide(false)

Actor becomes visible again on reset events

No crashes, no stuck invisibility

STOP CONDITIONS (ASK BEFORE PROCEEDING)

If only parent-node invisibility appears possible

If shape-level visibility APIs are unclear or unsafe

If reset cannot reliably restore visibility

If any change would affect existing systems outside FBHide

END OF ASSIGNMENT DESCRIPTION

CHECKLIST
PHASE 0 — Scope & Guardrails

Confirm FBHide v1 is broad hide only.

Do not implement:

body-part targeting

BSDismember partition logic

mesh-specific heuristics

asset correction or enforcement

Confirm this module is independent of FBScaler / FBMorph except for reset wiring.

Confirm all logging is gated behind existing debug/log flags.

Checkpoint: Scope is minimal, broad, and reset-focused.
Stop Condition: Any need to inspect partitions, bones, or asset metadata beyond shape traversal.

PHASE 1 — Public Module Interface

Implement an FBHide module with a minimal, explicit surface:

ApplyHide(RE::Actor*, bool hide)

ResetActor(RE::Actor*)

(Optional, debug-only) ResetAll()

Rules:

FBHide owns all state it mutates.

No direct calls from animation listeners.

ActorManager is the sole orchestrator.

Checkpoint: FBHide can be called safely with a valid or invalid actor pointer.
Stop Condition: Module requires scheduler, threading, or hooks outside ActorManager flow.

PHASE 2 — Shape Traversal (Read-Only Pass)

When applying hide or reset:

Acquire actor 3D safely.

Traverse renderable geometry only:

Include: BSTriShape / NiGeometry

Exclude: bones, helper NiNodes, non-geometry nodes

Do not assume:

shape count

partition layout

consistent naming across assets

Traversal rules:

Traversal is stateless.

No mutation during this phase.

No raw pointers cached beyond the current pass.

Checkpoint: Traversal yields a deterministic list of render shapes when 3D is present.
Stop Condition: Only parent-node or skeleton-level visibility is accessible.

PHASE 3 — Baseline Capture (First Touch Only)

Baseline rules:

Baseline is captured once per actor per shape.

Baseline represents the exact visibility state as observed at first touch.

Never overwrite baseline on subsequent calls.

Storage rules (v1-safe, non-overengineered):

Store baseline keyed by:

Actor FormID

Shape name (string)

Optional: immediate parent name (best-effort only)

Do not store raw pointers long-term.

Cached data = keys + baseline visibility state only.

Hard rule:

Never dereference cached raw pointers unless actively inside the same traversal/apply pass.

Checkpoint: Baseline map grows only on first interaction per shape.
Stop Condition: Implementation relies on persistent raw pointers or assumes stable mesh paths.

PHASE 4 — Apply Hide

Hide semantics (v1):

Use one concrete visibility mechanism only (e.g., hidden flag).

Apply the same mechanism consistently for hide and restore.

Do not mix alpha, scale, or detach behavior.

Application rules:

If baseline exists → apply hide only.

If baseline does not exist → capture baseline, then apply hide.

If actor has no 3D → no-op safely.

Checkpoint: Repeated hide calls do not corrupt baseline state.
Stop Condition: Hide cannot be reversed using the same mechanism.

PHASE 5 — Reset Semantics

Reset behavior:

Triggered exclusively by ActorManager:

PairEnd

PairedStop

CancelAndReset

Must be called for both caster and target.

Reset rules:

If actor 3D is present:

Re-traverse shapes.

Restore best-effort matches using stored keys.

If actor 3D is missing:

Safely clear FBHide state for that actor.

Do not attempt restoration.

Emit debug-only log noting skipped restore.

After reset:

FBHide holds no residual state for that actor.

Checkpoint: Reset restores baseline when possible and never crashes.
Hard Stop Condition: Reset wired for only one participant.

PHASE 6 — Logging & Observability (Debug Only)

When debug/logOps enabled:

Log:

number of shapes discovered

number hidden

number restored

Log skipped restore due to missing 3D.

No per-frame or per-shape spam in release logging.

Checkpoint: Logs are useful, sparse, and gated.
Stop Condition: Logging required for correctness.

PHASE 7 — Validation Scenarios

Manual / in-game validation:

Hide + reset with:

simple humanoid NPC

modded NPC with custom meshes

Repeated hide calls without reset.

PairEnd and PairedStop both restore correctly.

Actor unload / reload (cell change, fast travel) between hide and reset:

No crash

Best-effort restore or safe clear

Confirm both caster and target are handled symmetrically.

Final Checkpoint:
FBHide v1 proves:

safe shape traversal

baseline capture

reversible hide/reset

clean ActorManager integration

Assignment complete only when all phases pass.



