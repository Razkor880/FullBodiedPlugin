YOURASSIGNMENT – FBHide (Initial Invisibility + Reset)

This assignment is scoped to implementing the initial FBHide module only. Read these instructions, and refer to the checklist below as you work through the assignment. 

The goal is to deliver a minimal, reliable invisibility toggle and reset that can be safely expanded later.

TASK GOAL

Implement a broad invisibility toggle using the module name FBHide, with full reset support.

FBHide must:

Hide visible geometry only (mesh/shapes), not skeleton nodes

Be actor-scoped and reversible

Work for both caster and target

Reset cleanly on PairEnd / PairedStop / CancelAndReset

Integrate into the existing INI -> Timeline -> ActorManager pipeline

This is a v1 feature. No body-part specificity is required yet.

NAMING CONSTRAINT (IMPORTANT)

FBHide is the canonical, user-facing name.

INI commands must use FBHide

Logs should refer to FBHide

Code identifiers may vary internally, but external naming must remain FBHide

Do not introduce alternate names such as FBVis, FBVisibility, or HideMesh at the user-facing level.

HARD CONSTRAINTS

Do NOT hide skeleton nodes or parent NiNodes

Do NOT rely on visibility inheritance

Do NOT introduce new threads, pumps, schedulers, or hooks

Do NOT break existing morph or scale behavior

Do NOT change INI grammar outside of adding FBHide(bool)

All operations must be safe on the game thread

RESET REQUIREMENT (CRITICAL)

Any visibility changes applied by FBHide must be fully undone by reset.

Reset must:

Restore original visibility state per shape

Apply to both caster and target

Run from existing reset paths (PairEnd / PairedStop / CancelAndReset)

No persistent invisibility is acceptable after reset.

IMPLEMENTATION EXPECTATIONS

Operate on renderable geometry (BSTriShape or equivalent)

Track baseline visibility state per actor

Restore exactly to baseline, not a hard-coded “visible” state

Safe no-op behavior if actor 3D is missing or unloaded

DELIVERABLE

FBHide(true/false) works in INI timelines.

Manual validation:

Actor becomes invisible when FBHide(true) executes

Actor becomes visible again on FBHide(false)

Actor becomes visible again on reset events

No crashes, no stuck invisibility

STOP CONDITIONS (ASK BEFORE PROCEEDING)

If only parent-node invisibility appears possible

If shape-level visibility APIs are unclear or unsafe

If reset cannot reliably restore visibility

If any change would affect existing systems outside FBHide

END OF ASSIGNMENT DESCRIPTION

CHECKLIST

PHASE 0 - CONTEXT + CONSTRAINTS

Goal is a minimal, reliable v1 invisibility feature that can be expanded later.

This phase is NOT body-part-specific. It is broad visibility toggle only.

Do NOT hide skeleton nodes or bones (no NiNode parent toggles).

Do hide renderable geometry (shapes) so we avoid parent/child inheritance issues.

Must be fully reversible and actor-scoped.

Must work for both caster and target (paired context).

Must not introduce new threads or timing systems.

Must not break existing INI/timeline/morph/scale systems.

Reset must restore original visibility for all touched shapes on CancelAndReset / PairEnd / PairedStop.

Keep logs behind existing debug/log flags (bLogOps etc).

Definition of “Hide” for v1

Hide means: prevent rendering of the actor’s visible geometry.

Implementation should operate on per-shape render objects (BSTriShape or equivalent), not bones.

The system should store original visibility state per shape and restore it exactly.

PHASE 1 - SURFACE API + COMMAND MODEL (MINIMAL)

1.1 Add a new module/class: FBHide

Files: FBHide.h / FBHide.cpp (or your project’s convention)

FBHide is actor-scoped and stores per-actor hide state.

1.2 Define minimum public API (names flexible, keep intent):

FBHide::SetHidden(actor, bool hidden)

FBHide::ResetActor(actor)

FBHide::ResetAll() (optional debug helper only; not used by gameplay)

FBHide::OnActor3DChanged(actor) (optional stub for future; no behavior required now)

1.3 Define the v1 command name (choose one and keep it stable):
Option A: FBHide(bool)
Option B: FBVis(bool)
Option C: FBHide_All(bool)

Pick one and use it consistently in INI parsing and execution.

Checkpoint A:
Code compiles with FBHide stubbed (no behavior changes yet).

PHASE 2 - SHAPE DISCOVERY (GAME THREAD ONLY)

2.1 Implement a traversal that collects renderable shapes from an actor’s current 3D.

Input: RE::Actor*

Requirement: actor must be 3D loaded; if not, no-op safely.

Traverse actor->Get3D() root, depth-first.

Collect objects that represent render geometry:

BSTriShape (preferred)

Any other renderable geometry type you already use in the codebase (keep minimal; start with BSTriShape if that’s enough)

2.2 For each collected shape, generate a stable “key” for tracking baseline state.

Prefer pointer identity while the 3D remains loaded.

Store also a string path/name for debug logs only.

2.3 Store baseline visibility state per shape the first time you touch an actor.

Do not store the entire actor tree forever; keep it scoped and clear it on reset.

Checkpoint B:
In-game debug logs can report: “Found N shapes for actor X” when SetHidden is called (behind debug flag).
No actual hiding yet.

PHASE 3 - APPLY HIDE (BROAD, NO INHERITANCE)

3.1 Implement FBHide::SetHidden(actor, hidden):

Ensure runs on game thread (same pattern as scaling/morph ops).

If actor has no 3D, no-op (optional log).

On first hide/unhide call for that actor:

Build shape list

Record baseline visibility state for each shape

Apply hide/unhide to each shape individually.

3.2 How to hide a shape (implementation detail):

Use a per-object visibility flag that affects rendering of that shape itself.

Do NOT toggle parent node visibility.

Do NOT detach nodes.

Do NOT scale to zero as a substitute for hide.

3.3 Behavior rules:

hidden = true:

Set each shape invisible

hidden = false:

Restore baseline state for each shape (not “force visible”)

This ensures compatibility if something was already invisible before FBHide touched it.

Checkpoint C:
Manual functional check:

Call FBHide(true) on a test actor -> actor geometry disappears

Call FBHide(false) -> actor geometry returns

PHASE 4 - RESET INTEGRATION (CRITICAL)

4.1 Integrate FBHide reset into ActorManager reset paths:

In CancelAndReset (or equivalent), call:

FBHide::ResetActor(caster)

FBHide::ResetActor(target)

Ensure this is consistent with how you reset morphs and scales.

This must run on both participants even if the stop event comes from one side.

4.2 Implement FBHide::ResetActor(actor):

If actor has tracked baseline state:

Restore each touched shape to its recorded baseline visibility state

Clear actor entry from FBHide state

Checkpoint D:
Functional check:

Trigger hide on NPC target, then stop paired animation (PairEnd / PairedStop).

Confirm NPC target becomes visible again.

Confirm caster also resets if hidden.

PHASE 5 - COMMAND WIRING (INI/TIMELINE)

5.1 Add parsing support for the v1 hide command in the INI timeline grammar.

Minimal format:
time FBHide(true)
time FBHide(false)

Accept boolean literals true/false (and optionally 1/0).

5.2 Route the parsed command through existing pipeline:
INI -> FBConfig -> Timeline -> ActorManager -> FBHide

Constraints:

Do not alter other parsing semantics.

StrictIni behavior consistent with existing style:

strict: malformed bool rejects

non-strict: logs and ignores line

Checkpoint E:
INI functional check:

Add two commands:

time 2.0 FBHide(true)

time 5.0 FBHide(false)

Trigger FBEvent and confirm hide/unhide at correct times.

PHASE 6 - SAFETY + EDGE CASES (MINIMAL)

6.1 Actor unload / 3D swap:

If stored shape pointers become invalid (actor unload), ResetActor should no-op safely.

Prefer: if actor has no 3D on reset, just clear FBHide’s state for that actor without applying changes.

6.2 Avoid long-lived stale state:

If an actor remains hidden and gear swaps, v1 can ignore this (known limitation).

Document in logs (debug only) if you detect shape count mismatch.

Do not attempt to handle equip-change invalidation in v1.

Checkpoint F:
Short play session check:

No CTDs when hiding/unhiding a few times.

Cancel/reset always restores visibility.

No performance spikes (shape traversal is only on hide/unhide, not every frame).

PHASE 7 - LOGGING (RESPECT FLAGS)

7.1 Add logs behind existing debug flags:

On SetHidden: actor, hidden, shapes count

On ResetActor: actor, restored count

On parse: time, bool value (optional)

Do not spam logs per frame.

DELIVERABLE COMPLETION CONDITIONS

FBHide module exists and compiles.

FBHide(true/false) works on both player and NPC.

Reset paths restore baseline visibility for both caster and target.

No skeleton-node invisibility used.

No new threads or schedulers.

No INI breaking changes.

Minimal logs present and gated.

STOP CONDITIONS (ASK BEFORE PROCEEDING)

If only a parent node visibility toggle appears feasible (do NOT do this) -> stop and ask.

If hiding shapes causes unexpected side effects (crashes, persistent invisibility) -> stop and ask with details and logs.

If CommonLib types don’t expose a safe per-shape visibility toggle -> stop and ask; we may need an alternative render flag approach.

END OF CHECKLIST



