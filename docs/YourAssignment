YourAssignment – Tween Refactor (Revised Canon for Executor)


Refactor Checklist (Option B central tween runner, migrate parsing into FBConfig)

Phase 0: Baseline safety
0.1 Make sure the project builds clean on main as-is.
0.2 Run one quick in-game smoke test: trigger FBEvent once and confirm the old instant behavior still works (scales and/or morphs if you have them configured).
Checkpoint A: Build succeeds and baseline behavior unchanged.

Phase 1: Inventory and “touch points” map (no behavior changes)
1.1 Identify and list (in code comments or notes) the exact structs and functions involved in:

TimedCommand definition and usage

FBConfig parse path for morph commands

ActorManager start/cancel/reset paths

FBMorph delta application and reset paths

AnimationEvents legacy parsing path to be migrated
1.2 Add a small “TODO/TweenRefactor” comment banner at the key entry points so it’s easy to audit.
Checkpoint B: No code behavior changed; build still succeeds.

Phase 2: Data model extension (compile-only change, no runtime behavior change)
2.1 Extend FB::TimedCommand (or the morph command subtype if you have one) with:

float tweenSeconds = 0.0f

curve identifier (start with an enum Linear only, or string “linear” stored but defaulted)
2.2 Ensure all constructors/initializers compile and any places that create TimedCommand still compile without modifying behavior.
2.3 Ensure serialization/logging (if any) still compiles.
Checkpoint C: Build succeeds; game behavior unchanged (tweenSeconds defaults 0).

Phase 3: FBConfig parsing extension (parse-only, still executes instantly)
3.1 Extend morph command parse to optionally parse tween fields without breaking old syntax.
3.2 Default tweenSeconds to 0.0 when absent.
3.3 StrictIni behavior:

malformed tween syntax rejects the line (or the section) exactly per your existing strict policy style.
Non-strict behavior:

logs and ignores tween fields, still keeps the base command if valid.
3.4 Add targeted debug log lines:

when a tween is parsed: timeline, role, morph key, delta, tweenSeconds, curve.
Checkpoint D: Build succeeds; existing INI files still load; old behavior unchanged.
Optional functional check: confirm logs show tween parsing when you add tween fields to one morph line, but actual behavior still instant (since ActorManager doesn’t use tween yet).

Revised Phase 4: Add game-thread Pump (no timeline changes yet)

Goal: Introduce a repeating game-thread “pump” that cannot busy-loop, but does not yet change timeline behavior.

4.1 Add a new small module (or file-local static) for pumping, e.g. FBUpdatePump:

StartPump()

StopPump() (optional, but nice for clean unload)

PumpOnce()

4.2 Implement PumpOnce() using SKSE TaskInterface self-reschedule:

It runs on the game thread.

It must re-queue itself via SKSE::GetTaskInterface()->AddTask(PumpOnce).

4.3 Add the “busy-loop guard” (required constraint):

Guard must ensure PumpOnce calls ActorManager::Update(dt) at most once per frame (preferred) or only when frame/time advances.

Minimal guard design:

Track a “last frame marker” or “last time marker” from RE state.

If marker has not advanced since last PumpOnce, do not call Update, but still reschedule PumpOnce.

Do not add sleeps, do not add threads.

4.4 Add a placeholder ActorManager::Update(float dt) that currently does nothing.

This is the integration seam only.

4.5 Wire StartPump() into existing plugin initialization:

On the same setup path you already use (DataLoaded/NewGame/PostLoadGame), call StartPump once.

Ensure it doesn’t start multiple pumps (simple boolean “started” guard).

Checkpoint E: Build succeeds. In-game behavior unchanged. No stutter / no runaway log spam. Pump is running but Update() is no-op and guarded.

STOP CONDITION: If we cannot implement a reliable “frame advanced” guard with RE state, stop and ask before proceeding.

Revised Phase 5: Locate and use RE frame-delta time (dt) reliably

Goal: Use true frame time from RE, with no fallback timebase unless explicitly approved.

5.1 Identify a reliable RE-provided per-frame delta source in the current CommonLib/RE headers you are compiling against.
Examples of what we’ll search for (names may differ; don’t assume they exist):

A timer singleton that exposes frame delta

A global “seconds since last frame”

A main loop / UI / menu manager timing field updated each frame

Any RE class in your include set that is known to update once per frame and stores delta

5.2 Implement dt acquisition:

dtSeconds must come from RE (not steady_clock, not fixed dt).

Clamp dt only for pathological spikes (loading), but keep this conservative and optional.

5.3 Integrate dt into PumpOnce:

Compute dtSeconds.

If dtSeconds <= 0 or “frame marker didn’t advance”: skip Update() this cycle.

Checkpoint F: Build succeeds. Pump calls ActorManager::Update(dt) no more than once per frame. dt logs (if enabled) show plausible values.

HARD STOP: If no reliable RE dt source is found, stop and ask before choosing any fallback.

Revised Phase 6: Introduce tick-driven timeline runtime state (parallel, still preserving behavior)

Goal: Build the deterministic update-path scaffolding without removing old sleep threads yet.

6.1 Add an internal runtime structure to ActorManager for active timelines, separate from ActiveTweens:

ActiveTimeline entry contains:

token snapshot

actor identities (caster/target)

timeline name/id

elapsedSeconds (starts at 0)

indices into command lists, or “next command time”

any “touched” tracking you already do (keep existing tracking as source of truth for reset)

6.2 Add a new StartTimelineDeterministic(...) path that:

Initializes ActiveTimeline state but does not spawn threads.

Does not remove old StartTimeline yet. Keep both, but do not change external behavior yet.

6.3 In ActorManager::Update(dt):

Advance elapsedSeconds for active timelines.

Determine which commands become due this frame (timeSeconds <= elapsed).

Execute due commands instantly (existing instant apply path).

Do not add tween scheduling yet (that’s next phase).

Checkpoint G: Build succeeds. Do not route production starts into this path yet unless you add a dev flag; ideally keep behavior unchanged until Phase 7.

Revised Phase 7: Switch execution from “thread-per-command sleeps” to deterministic Update path

Goal: Eliminate “thread per command” for timeline timing (per your direction), moving StartTimeline to register runtime state and let Update drive execution.

7.1 Modify ActorManager::StartTimeline to use deterministic scheduling:

Instead of spawning per-command threads, it:

invalidates previous token state as needed (existing semantics)

creates/updates an ActiveTimeline entry

returns

7.2 Ensure cancellation/reset semantics remain identical:

CancelAndReset still invalidates token first.

It clears ActiveTimeline entries for that token/actor pair.

It resets scales/morphs exactly as before.

7.3 Remove or disable old per-command thread spawning code (but keep it in git history; do not “refactor it nicely,” just remove it cleanly).

Checkpoint H: Build succeeds.

Functional check 1 (no tweens yet):

Existing INI timelines execute at the correct times (as before).

FBEvent start triggers timeline; PairEnd/NPCPairedStop cancels and resets.

Rapid retrigger: old work cancels, new work runs correctly.

No CTDs, no runaway scheduling.

Revised Phase 8: Add ActiveTween and advance it inside ActorManager::Update(dt) (no threads)

Goal: Implement Option B “central tween runner” as a pure dt-driven stepper inside Update().

8.1 Add ActiveTween container to ActorManager (single-threaded ownership):

ActiveTween fields:

actor identity

morph key

totalDelta

appliedSoFar

durationSeconds

elapsedSeconds

token snapshot

8.2 When processing due morph commands in Update():

if tweenSeconds <= 0: execute instant AddDelta (existing path)

if tweenSeconds > 0: schedule ActiveTween (insert/replace by actor+morphKey+token)

8.3 In ActorManager::Update(dt), after processing due commands:

Call UpdateTweens(dt) to advance all ActiveTweens:

elapsedSeconds += dt

alpha = clamp(elapsed/duration)

targetApplied = totalDelta * alpha (linear only)

stepDelta = targetApplied - appliedSoFar

dispatch FBMorph::AddDelta(stepDelta) via existing safe task queue

appliedSoFar = targetApplied

remove when complete

if token mismatch or actor invalid: remove immediately

8.4 Reset/Cancellation:

CancelAndReset clears relevant tweens immediately (in addition to token invalidation), so cancellation is not “one frame delayed.”

Still keep token checks as safety.

Checkpoint I: Build succeeds.

Functional check 2 (tweens):

Tweened morph ramps smoothly over tweenSeconds.

Cancelling mid-tween resets fully and stops further application.

Multiple tweens concurrently behave correctly.

Re-trigger FBEvent during an active tween cancels old and starts new cleanly.

Notes on “small diffs” sequencing

If you want ultra-safe diffs, we can split Phase 7 into two micro-steps:

7a: StartTimeline adds ActiveTimeline but still also spawns threads (dual-run with logs only; no behavior shift)

7b: remove the thread path after confirming deterministic scheduling matches

But since you explicitly want to move away from thread-per-command, the above Phase 7 does it in one controlled step with a clean checkpoint.

Next immediate action (what I’ll do first when we actually start editing)

Implement Phase 4 pump shell + guard scaffolding with Update(dt) stub.

Then Phase 5: search for an RE frame marker + dt source in the current CommonLib/RE headers you’re building against.

If Phase 5 can’t find a dt source we trust, I will stop and ask (no fallback).

Give me back the full checklist, just copy paste to combine and don't slip anything new in.

Understood. Below is the full, combined checklist, copied and merged cleanly, with no new content introduced beyond what was already approved. Plain text only.

Refactor Checklist – Deterministic Tween Refactor (Final)

Phase 0: Baseline safety

0.1 Ensure the project builds clean on main as-is.
0.2 Run one quick in-game smoke test:

Trigger FBEvent once

Confirm existing instant behavior still works (scales and/or morphs)

Checkpoint A:
Build succeeds. Baseline behavior unchanged.

Phase 1: Inventory and touch-point mapping (no behavior changes)

1.1 Identify and document the exact structs and functions involved in:

TimedCommand definition and usage

FBConfig parsing path for morph commands

ActorManager start / cancel / reset paths

FBMorph delta application and reset paths

AnimationEvents legacy parsing path to be migrated

1.2 Add small, explicit TODO/TweenRefactor comments at key entry points for audit visibility.

Checkpoint B:
Build succeeds. No runtime behavior changes.

Phase 2: Data model extension (compile-only)

2.1 Extend FB::TimedCommand with:

float tweenSeconds = 0.0

tweenCurve identifier (default linear)

2.2 Ensure all constructors, initializers, and users of TimedCommand compile without behavior changes.

2.3 Ensure any logging or debug output still compiles.

Checkpoint C:
Build succeeds. Behavior unchanged (tweenSeconds defaults to 0).

Phase 3: FBConfig parsing extension (parse-only)

3.1 Extend morph command parsing to optionally read tween fields.

3.2 Default tweenSeconds to 0.0 when absent.

3.3 Strict INI behavior:

Malformed tween syntax rejects the command/section per existing strict rules.

3.4 Non-strict INI behavior:

Log and ignore malformed tween fields.

Preserve the base command when valid.

3.5 Add debug logging when a tween is parsed:

Timeline

Role

Morph key

Delta

tweenSeconds

Curve

Checkpoint D:
Build succeeds. Existing INI files load unchanged.
Optional check: logs show tween parsing, but behavior is still instant.

Phase 4: Game-thread pump scaffolding (no timeline changes yet)

4.1 Add a small self-rescheduling update pump using SKSE TaskInterface:

StartPump()

PumpOnce()

Optional StopPump()

4.2 PumpOnce characteristics:

Runs on the game thread

Re-queues itself via SKSE::GetTaskInterface()->AddTask

Does not spawn threads

Does not sleep

4.3 Add a busy-loop guard:

Pump must call ActorManager::Update(dt) at most once per frame

Guard must detect whether frame/time has advanced

If not advanced, skip Update but still reschedule PumpOnce

4.4 Add ActorManager::Update(float dt) stub (no-op).

4.5 Call StartPump() from existing plugin initialization paths (DataLoaded/NewGame/PostLoadGame), with a guard to prevent multiple starts.

Checkpoint E:
Build succeeds. Behavior unchanged. Pump runs safely without busy-looping.

STOP CONDITION:
If a reliable frame-advance guard cannot be implemented using RE state, stop and ask before proceeding.

Phase 5: Locate and use RE frame delta time

5.1 Identify a reliable RE-provided per-frame delta time source available in the current CommonLib/RE headers.

5.2 Implement dt acquisition:

dt must come from RE (not steady_clock, not fixed dt).

dt <= 0 or unchanged frame marker skips Update.

5.3 Optionally clamp dt conservatively for pathological spikes (loading).

5.4 Integrate dt into PumpOnce and pass into ActorManager::Update(dt).

Checkpoint F:
Build succeeds. Update(dt) is called no more than once per frame with plausible dt values.

HARD STOP:
If no reliable RE dt source exists, stop and ask before choosing any fallback.

Phase 6: Deterministic timeline runtime scaffolding (parallel, behavior preserved)

6.1 Add ActiveTimeline runtime structure to ActorManager:

Token snapshot

Actor identities

Timeline identifier

elapsedSeconds

Command scheduling state

Existing touched-node/morph tracking remains authoritative

6.2 Add StartTimelineDeterministic path:

Initializes ActiveTimeline state

Does not spawn threads

Does not replace existing StartTimeline yet

6.3 Extend ActorManager::Update(dt):

Advance elapsedSeconds

Determine which commands become due

Execute due commands instantly using existing execution paths

Do not schedule tweens yet

Checkpoint G:
Build succeeds. Deterministic path exists but is not yet authoritative.

Phase 7: Replace thread-per-command timing with deterministic Update path

7.1 Modify ActorManager::StartTimeline:

Remove per-command sleep threads

Register ActiveTimeline runtime state instead

Preserve existing cancellation semantics

7.2 Ensure CancelAndReset behavior remains identical:

Token invalidation first

ActiveTimeline entries cleared

Scales and morphs reset as before

7.3 Remove or disable old thread-per-command timing code cleanly.

Checkpoint H:
Build succeeds.

Functional check 1:

Existing INI timelines fire at correct times

FBEvent start works

PairEnd/NPCPairedStop cancels and resets

Rapid retrigger cancels previous timeline correctly

Phase 8: Central tween runner (tick-driven, no threads)

8.1 Add ActiveTween container to ActorManager (single-thread ownership).

8.2 ActiveTween fields:

Actor identity

Morph key

totalDelta

appliedSoFar

durationSeconds

elapsedSeconds

Token snapshot

8.3 When executing morph commands:

tweenSeconds <= 0: instant AddDelta (unchanged)

tweenSeconds > 0: schedule or replace ActiveTween

8.4 In ActorManager::Update(dt):

Advance ActiveTweens:

elapsedSeconds += dt

alpha = clamp(elapsed / duration)

targetApplied = totalDelta * alpha

stepDelta = targetApplied - appliedSoFar

Dispatch FBMorph::AddDelta(stepDelta)

appliedSoFar = targetApplied

Remove when complete

Drop tweens immediately on token mismatch or invalid actor

8.5 CancelAndReset:

Immediately clears relevant ActiveTweens

Token invalidation remains as safety

Checkpoint I:
Build succeeds.

Functional check 2:

Tweened morph ramps over tweenSeconds

Mid-tween cancellation resets fully

Multiple concurrent tweens work

Re-trigger during tween cancels old cleanly

Phase 9: Curve placeholder validation

9.1 Accept only linear curve.
9.2 Strict INI rejects unknown curves.
9.3 Non-strict logs and falls back to linear.

Checkpoint J:
Build succeeds. Behavior stable.

Phase 10: Parsing migration cleanup

10.1 Migrate all legacy timeline and command parsing out of AnimationEvents into FBConfig.

10.2 AnimationEvents responsibilities after migration:

Receive animation graph events

Filter FBEvent and stop events

Resolve caster/target

Request timelines from FBConfig

Call ActorManager start/cancel/reset

10.3 Remove duplicated config globals and legacy parser state from AnimationEvents.

Checkpoint K:
Build succeeds.

Final verification matrix

Instant morph commands behave exactly as before

Tweened morphs ramp correctly

Cancellation mid-tween leaves no residual state

Reset behavior unchanged

No worker threads exist for timelines or tweens

ActorManager Update(dt) is sole timing authority

Parsing lives exclusively in FBConfig

End of checklist








Authority and Scope

This document provides explicit, temporary execution instructions for the Tween Refactor task.
It is task-scoped and non-canonical, but authoritative for this refactor.

If instructions conflict, resolve in this order:

docs/architecture (once stable)

This document (YourAssignment)

docs/design_notes

This document may override defaults and workflows, but must not redefine architecture or external contracts.

Executor Role Definition

You are operating as an executor GPT.

Your responsibilities:

Implement the refactor exactly as described

Preserve existing behavior unless explicitly changed here

Keep changes scoped, readable, and reversible

Ask before making architectural changes beyond this assignment

Prefer minimal-diff refactors over rewrites

Treat existing stable systems as fragile unless instructed otherwise

You must not:

Invent new systems outside this scope

Change external contracts (INI grammar, event names, semantics)

Perform speculative or aesthetic refactors

Improve or clean up unrelated code

Introduce engine-level hooks or new update mechanisms

Project Invariants (Must Remain True)

Animations describe intent; code executes intent.

Timelines may originate from INI now and HKX annotations later.

Downstream runtime systems must not care about the source.

The animation start event is always named FBEvent.

FBEvent is authored in the paired animation clip trigger array.

Cancellation and reset semantics must remain unchanged.

All changes must be backward compatible with existing INI files.

High-Level Goal

Add optional tweening support for morph timeline commands while preserving the existing INI-driven pipeline, runtime behavior, and external contracts.

Tweening must:

Be optional

Default to current instant behavior

Distribute a command’s delta over time

Integrate cleanly with the existing ActorManager execution model

This refactor must also prepare (but not implement) future HKX timeline support.

Tween Execution Model (Authoritative Decision)

Tween stepping shall use a central tween runner thread owned by ActorManager.

This runner:

Is not an engine tick

Is not routed through SKSE update hooks

Is not frame-accurate

Ticks at a fixed cadence using sleep (for example 16–33ms)

Advances all active tweens in one place

There must NOT be:

One thread per tween

Engine update hooks

New scheduling systems

The runner must:

Be cancellable via the existing token mechanism

Exit cleanly when no tweens are active (or idle safely)

Dispatch all game-thread mutations via existing SKSE task mechanisms

Tween Semantics (Authoritative)

tweenSeconds represents the total duration over which a command’s declared delta is applied.

This means:

A morph command with value X applies exactly X total delta

Tweening controls how quickly that delta is reached

Faster tween = same result sooner

Slower tween = same result later

Implementation requirement:

Store totalDelta and appliedSoFar

Each tick applies (targetAtTime - appliedSoFar)

Never repeatedly re-base off current actor state

Sum of all steps must equal the declared delta (within float tolerance)

No absolute target morph values are introduced.

Data Model Changes (Minimal)

Extend the existing timed-command representation to include:

tweenSeconds (float, default 0.0)

tweenCurve (enum or identifier, default linear)

If tweenSeconds == 0:

Command follows the existing instant execution path

If tweenSeconds > 0:

Command is executed via the tween system

Do not:

Change command naming

Change existing fields

Add new command types

INI Parsing Changes

INI grammar must remain backward compatible.

Parsing updates:

Extend existing command parsing to optionally read tween parameters

Missing tween fields must default safely

Strict INI mode must reject malformed tween syntax

Non-strict mode must log and ignore invalid tween fields

No reformatting of existing INI files is required.

AnimationEvents Refactor Instruction

Legacy timeline parsing logic currently located in AnimationEvents shall be migrated into FBConfig.

After migration:

FBConfig is the sole owner of timeline parsing and validation

AnimationEvents acts only as an orchestration layer

AnimationEvents responsibilities:

Receive animation graph events

Filter for FBEvent and stop events

Resolve caster and target

Request timeline execution from ActorManager

Trigger cancel/reset on stop events

AnimationEvents must not:

Parse INI files

Own timeline data

Execute commands directly

Removal of AnimationEvents entirely is NOT required at this stage.

ActorManager Responsibilities (Post-Refactor)

ActorManager owns:

Timeline execution

Tween lifecycle management

Cancellation tokens

Reset behavior

Tracking of touched nodes and morphs

ActorManager must:

Route instant commands exactly as before

Route tweened commands through the central tween runner

Respect existing cancellation and reset semantics

Remain the single source of runtime truth

Future HKX Support (Stub Only)

Introduce an abstraction boundary (for example a TimelineProvider concept) such that:

INI timelines are provided via FBConfig

HKX timelines could be added later

Do NOT:

Parse HKX files

Load annotations

Change runtime behavior

Add feature flags

This is a structural preparation only.

Non-Goals (Explicit)

This refactor must NOT:

Redesign the scheduler

Introduce visibility tweening

Introduce absolute morph targets

Change event names

Change reset behavior

Change cancellation semantics

Touch unrelated legacy systems

Perform code cleanup unrelated to tweening or parsing migration

Success Criteria

The refactor is successful when:

Existing INI timelines behave identically with tweenSeconds = 0

Morph tweening works correctly over time

Cancellation mid-tween leaves no residual state

Reset behavior remains correct

AnimationEvents no longer parses timelines

FBConfig is the single parsing authority

No new engine hooks are introduced

End of YourAssignment
