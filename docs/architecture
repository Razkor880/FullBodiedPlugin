# Full Bodied Animation – Architecture

This document describes the intended architecture of the Full Bodied Animation (FBA) system.

Unless explicitly stated otherwise, systems described here are assumed to be correct and preferred **once they have demonstrated consistent runtime behavior**.

---

## Core Principle

> **Animations describe intent. Code executes intent.**

The animation system provides timing and context.  
The SKSE plugin provides interpretation, safety, and execution.

---

## High-Level Flow

Animation Context (event, paired state)
↓
Input Source (INI today, annotations later)
↓
Unified Internal Event Representation
↓
Actor Context Resolution
↓
Effect Scheduling
↓
Runtime Effect Application
↓
Cleanup / Reversion

---

## Input Sources: INI and Annotations

The system is designed so that **INI-based timelines and HKX annotations feed the same internal pipeline**.

- **INI files**
  - External, editable timelines
  - Keyed by animation and role
- **Annotations**
  - Embedded, per-clip timing and parameters

Both are translated into the same internal event representation before any effects are applied.

> No downstream system should need to know whether an effect originated from an INI or an annotation.

---

## INI Structure and Stability Contract

The INI format is an **external contract**.

### Stable Assumptions
- Section headers identify animation context and role
- Timeline entries are ordered by time
- Event names and parameter ordering are stable

### Changes That Will Break Parsers or Scripts
- Event naming conventions
- Parameter ordering
- Section header grammar

Internal parsing may evolve, but **the external INI grammar must remain stable once declared canon**.

---

## Major Modules

### AnimEventListener
- Registers animation graph event sinks
- Receives animation events
- Does **not** parse parameters
- Does **not** apply effects

### AnimationEvents
- Interprets raw event payloads
- Normalizes event names and parameters
- Produces structured internal events

### ActorManager
- Resolves actor roles (caster, target, paired participants)
- Tracks active animation participants
- Owns actor-scoped state

### FBConfig
- Loads and validates INI configuration
- Provides timelines and tunables
- Owns no runtime state

### FBScaler
- Applies and reverts NiNode scale changes
- Preserves original values
- Must be fully reversible and actor-scoped

### FBMorph
- Bridges runtime intent to morph systems
- Must remain modular and optional

---

## Paired Animation Assumptions

- Paired context is supported but not required
- Actor roles must be explicit
- No reliance on killmove-only mechanics

---

## Canon and Stability

A system becomes **canon** only after:

- Consistent runtime behavior
- Repeatable testing success
- No hidden cross-module coupling

Until then, it is considered **provisional**.

---

## On `YourAssignment`

`docs/YourAssignment` does **not** define architecture.

It may provide explicit, temporary instructions for execution, testing, or refactoring, but it does not override or reinterpret this document.

> If there is a conflict, **architecture takes precedence**.

---

## Architectural North Star

- Animators can author behavior without touching code
- Programmers can add effects without touching animations
- INI and annotation inputs converge on one execution path
- Behavior graphs remain readable and minimal
